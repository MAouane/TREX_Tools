import matplotlib.pyplot as plt
import numpy as np
from matplotlib.cm import get_cmap

def style_axes(ax):
    # Apply all preferred formatting to the axes object ax
    ax.minorticks_on()
    ax.grid(True, which='both', linestyle=':', linewidth=0.7, alpha=0.7)
    ax.tick_params(axis='both', which='major', labelsize=14)
    ax.tick_params(axis='both', which='minor', labelsize=12)

''' Constants and functions to convert between ToF, Energy in meV and Wavelengths in Å'''
TOF_CONSTANT = 252.78  # µs·Å-1·m-1 for conversion between lambda and ToF
ENERGY_CONSTANT = 81.8042  # meV·Å**2
H_OVER_MN = 3956  # m/s

''' T-REX Specific Distances '''
L_sample = 163.8   # Source to sample in m
L_detector = 3.0   # Sample to detector in m
L_total = L_sample + L_detector
LM = 162.0  # Distance to the M-chopper

# Conversion functions
def energy_to_wavelength(E):
    return np.sqrt(ENERGY_CONSTANT / E)

def wavelength_to_energy(lam):
    return ENERGY_CONSTANT / lam**2

def Lechner(Ld, lambda_f, lambda_i, tau_M, tau_P):
    '''
    Calculate energy resolution using Lechner Formula.
    Inputs:
        - Ld: Any flight path uncertainties, in mm
        - lambda_f: Scattered wavelength in Å
        - lambda_i: Incident wavelength in Å
        - tau_M: M-chopper opening time (seconds)
        - tau_P: P-chopper opening time (seconds)
    Outputs:
        - Returns delta E / FWHM in meV
    '''
    # Convert Ld from mm to m
    dL = Ld * 1e-3
    lambda_i = lambda_i *1e-10
    lambda_f = lambda_f *1e-10

    A = (0.2041*tau_M) * (L_PM + L_MS + L_SD * (lambda_f**3 / lambda_i**3))  # [A] = s * m
    B = (0.2887*tau_P) * (L_MS + L_SD * (lambda_f**3 / lambda_i**3))         # [B] = s * m
    C = mn * L_PM * lambda_f * dL / h                                        # [C] = s * m

    # Final energy resolution calculation
    return ((h**3.)/(mn**2)) * np.sqrt((A*A) + (B*B) + (C*C)) * 1./(L_SD * L_PM * (lambda_f**3.)) * 6.21 * 1e21  # Convert Joules -> meV

BANDWIDTH = 0.845      # Half-bandwidth for wavelength range
def generate_wavelengths(central_wavelength, fM):    
    """    Generate evenly spaced wavelengths based on fM, ensuring λ_c is included.    
    Parameters:        
    central_wavelength (float): Central wavelength (Å).        
    fM (float): Chopper frequency (Hz; between 14 and 336).    
    Returns:        
    list: List of wavelengths in Å.    """    
    lambda_min = central_wavelength - BANDWIDTH    
    lambda_max = central_wavelength + BANDWIDTH    
    delta_lambda = 3956. / (fM * LM)    
    wavelengths_below = []    
    current_lambda = central_wavelength    
    while current_lambda > lambda_min:        
        current_lambda -= delta_lambda        
        if current_lambda >= lambda_min:            
            wavelengths_below.append(current_lambda)    
    wavelengths_above = []    
    current_lambda = central_wavelength    
    while current_lambda < lambda_max:        
        current_lambda += delta_lambda        
        if current_lambda <= lambda_max:            
            wavelengths_above.append(current_lambda)    
    wavelengths_below.reverse()    
    return wavelengths_below + [central_wavelength] + wavelengths_above

print('-------------------------------------------------------------------------')
print('Script calculates the inelastic resolution of a chosen setting - Optimised at the elastic line')

central_wavelength = 8 #Central wavelength for your setting
fM = 82 # M-Chopper frequency in Hz (must be multiple of 14 between 14–336). The multiple defines how many reps you get on the sample
Lambda_Reps = generate_wavelengths(central_wavelength, fM)

print('-------------------------------------------------------------------------')
print(f'Wavelengths generated by this RRM setting of λc = {central_wavelength}Å and fM = {fM}Hz are:')
for i in range(len(Lambda_Reps)):
    print(f'λi = {Lambda_Reps[i]:.2f} Å, Ei = {wavelength_to_energy(Lambda_Reps[i]):.2f}meV')

import scipy.constants as cte

# Constants
h = cte.h                          # Planck constant
mn = cte.m_n                       # Neutron mass
L_SD = 3.0                         # Sample to detector distance in m
L_PM = 54.0 #LM - 108.0                  # P- to M-chopper distance in m
#print(L_PM)
L_MS = 1.8                         # M-chopper to sample distance in m

# Figure parameters
Ld = 20.0  # Flight path uncertainty in mm
steps = np.arange(1, 0., -0.05)  # Range of energy loss
#Lambda_Reps = [4]#[1, 1.2, 1.4, 1.65]
#Lambda_Reps = [6.5]#, 4.5, 5.0, 6.5]
n_lines = len(Lambda_Reps)

#cmap = plt.get_cmap('coolwarm_r')

# Define setups for the two conditions
setups = [
    {"fM": fM, "M_opening":2.5, "P_opening":20, "P_num":2, "tau_factor_m": 2, "tau_factor_p": 2, "label_desc": "High Resolution", "cmap": "inferno", 'linestyle': '--', 'marker': 's'},
   # {"fM": fM, "M_opening":4.4, "P_opening":35, "P_num":2, "tau_factor_m": 2, "tau_factor_p": 2, "label_desc": "High Flux", "cmap": "inferno", 'linestyle': '-', 'marker': 's'},
   # {"fM": fM, "M_opening":4.4, "P_opening":35, "P_num":2, "tau_factor_m": 2, "tau_factor_p": 2, "label_desc": "High Flux", "cmap": "inferno", 'linestyle': '--', 'marker': 's'},
]

print('-------------------------------------------------------------------------')
print('Inelastic resolution calculation for a given wavelength')
print('-------------------------------------------------------------------------')
print('Script uses the Lechner formula for the resolution calculation')
print('-------------------------------------------------------------------------')
print('Script will warn you if your pulse/width ratio is not optimised for flux/resolution')
print('-------------------------------------------------------------------------')
print('High resolution openings of the PS- and M-choppers used in this script')
print('-------------------------------------------------------------------------')
print('Triangular transmission function at the M-chopper: τM is multiplied by 0.2041')
print('-------------------------------------------------------------------------')
print('Top-Hat transmission function at the PS-chopper: τP is multiplied by 0.2887')
print('-------------------------------------------------------------------------')


for setup in setups:
    fig, ax = plt.subplots(figsize=(16, 8))
    fig1, ax1 = plt.subplots(figsize=(16, 8))

    fM = setup["fM"]
    P_opening = setup["P_opening"]
    M_opening = setup["M_opening"]
    tau_factor_m = setup["tau_factor_m"]
    tau_factor_p = setup["tau_factor_p"]
    linestyle = setup["linestyle"]
    label_desc = setup["label_desc"]
    marker = setup["marker"]
    cmap_ = setup["cmap"]
    fP = 0.75 * fM  # P-Chopper frequency
    cmap = plt.get_cmap(cmap_)

    # Calculate chopper opening times
    tau_M = M_opening / tau_factor_m / 360. / fM  # M-chopper opening time in s
    if tau_factor_m == 2:
        tau_P = tau_M * (L_PM + L_MS + L_SD)/(L_MS + L_SD) #P_opening / tau_factor_p / 360. / fP         # P-chopper opening time in s
   # else:
   # tau_P = P_opening / tau_factor_p / 360. / fP #P_opening / tau_factor_p / 360. / fP         # P-chopper opening time in s


    print(f'Ratio between opening times:, {(tau_P/tau_M):.2f}')
    print(f'Distance Ratio on T-REX:, {(L_SD+L_MS+L_PM)/(L_SD+L_MS):.2f}')
    print('-------------------------------------------------------------------------')
    if f'{tau_P/tau_M:.2f}' == f'{(L_SD+L_MS+L_PM)/(L_SD+L_MS):.2f}':
        print('Optimised Performance for Flux/Resolution Trade-Off at the elastic line')
    else:
        print('Unoptimised Instrument. Check the PS- and M-choppers Opening Times')
    print('-------------------------------------------------------------------------')

    for i in range(len(Lambda_Reps)):
        dE_vals_Matched = []
        Res_vals_Matched = []
        Elastic_Res = []
        Elastic_Res_meV = []
        color = cmap(i / n_lines)
        
        if Lambda_Reps[i] < 0.7:
            print(f'{Lambda_Reps[i]:.2f}Å is outside the T-REX/ESS range - Skipping')
        
        else:
        # Generate label only once for each line (based on wavelength)
        #label = f'λ = {round(Lambda_Reps[i], 2)}Å - {label_desc}, Optimised'
            label = f'Ei = {wavelength_to_energy(Lambda_Reps[i]):.2f}meV- λi = {Lambda_Reps[i]:.2f}Å'

            for j in range(len(steps)):
                lambda_f = np.sqrt(1./steps[j]) * Lambda_Reps[i]
                lambda_i = Lambda_Reps[i] 
                Resolution_FWHM_Matched = Lechner(Ld, lambda_f , lambda_i , tau_M, tau_P)
                
                if lambda_i == lambda_f:
                    Elastic_Res = 100 * Lechner(Ld, lambda_f, lambda_i, tau_M, tau_P) / wavelength_to_energy(lambda_i)
                    Elastic_Res_meV = Lechner(Ld, lambda_f, lambda_i, tau_M, tau_P)
                    
                # Append dE_vals and Res_vals
                dE_vals_Matched.append(wavelength_to_energy(lambda_i) - wavelength_to_energy(lambda_f))
                Res_vals_Matched.append(Resolution_FWHM_Matched)

            # Plot line with label
            ax.plot(dE_vals_Matched, Res_vals_Matched, linestyle, color=color, label=label, marker = marker, markersize = 5)
            ax1.plot(f'{wavelength_to_energy(lambda_i):.2f}', Elastic_Res, ls = '', marker = 'o', markersize = 6, color = color, label = f'Ei = {wavelength_to_energy(lambda_i):.2f}meV - λi = {lambda_i:.2f}Å')
            print('-------------------------------------------------------------------------')
            print(f'For {lambda_i:.2f}Å or {wavelength_to_energy(lambda_i):.2f}meV:')
            print(f'DE/Ei is: {Elastic_Res:.3f}')
            if lambda_i > 2.5:
                print(f'The elastic FWHM is: {Elastic_Res_meV*1e3:.4f}ueV')
            else:
                print(f'The elastic FWHM is: {Elastic_Res_meV:.2f}meV')

       
    style_axes(ax)
    style_axes(ax1)

    # Set labels, title, legend, and show for ax
    ax.set_xlabel("Energy Transfer (meV)", fontsize=14)
    ax.set_ylabel("$\Delta$E (meV)", fontsize=14)
    ax.legend(fontsize=13)
    ax.set_title(f"T-REX Performance - λc = {central_wavelength}Å - fM = {fM}Hz - {label_desc}" , fontsize = 15)
    fig.tight_layout()
    fig.show()

    # Set labels, title, legend, and show for ax1
    ax1.set_xlabel("Incident Energy (meV)", fontsize=14)
    ax1.set_ylabel("$\Delta$E/Ei (in %)", fontsize=14)
    ax1.legend(fontsize=13)
    #ax1.set_yscale("log")
    ax1.set_title(f"T-REX Elastic Resolution - λc = {central_wavelength}Å - fM = {fM}Hz" , fontsize = 15)
    fig1.tight_layout()
    fig1.show()
